# -*- coding: utf-8 -*-
"""Copy of Welcome To Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zphzPcYKEZmcy4w9Cz5itF788ZkZGK8m
"""

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler ## for scaling
from sklearn.cluster import KMeans

df = pd.read_csv("online_retail_II.csv")

#This helps understand columns, data types, and missing values.
df.info()

#This gives quick statistics for numerical columns
df.describe()

# remove missing values from CustomerID column
df = df.dropna(subset=['Customer ID'])
df.describe()
print(len(df))

# remove rows when quantity is negative
df = df[df['Quantity'] > 0]
print(len(df))

# Create TotalAmount = Quantity Ã— UnitPrice
df['TotalAmount'] = df['Quantity'] * df['Price']

# convert to datetime
df["InvoiceDate"] = pd.to_datetime(df["InvoiceDate"])

# calculate Recency.
snapshot_date = df["InvoiceDate"].max() + pd.Timedelta(days=1)
print(snapshot_date)

# create the RFM
rfm = df.groupby("Customer ID").agg({
    "InvoiceDate": lambda x: (snapshot_date - x.max()).days,  # Recency
    "Customer ID": "count",                                     # Frequency
    "TotalAmount": "sum"                                       # Monetary
})

rfm.columns = ["Recency", "Frequency", "Monetary"]

print(rfm)

rfm.to_csv("rfm.csv")

# EDA phase
plt.hist(rfm["Monetary"], bins=30)
plt.title("Distribution of Monetary Value")
plt.xlabel("Total Spend")
plt.ylabel("Number of Customers")
plt.show()

plt.hist(rfm["Recency"], bins=30)
plt.title("Distribution of Recency")
plt.show()

plt.hist(rfm["Frequency"], bins=30)
plt.title("Distribution of Frequency")
plt.show()

# Boxplot
plt.boxplot(rfm["Monetary"])
plt.title("Monetary Value Boxplot")
plt.ylabel("Total Spend")
plt.show()

plt.boxplot(rfm["Frequency"])
plt.title("Frequency Boxplot")
plt.ylabel("Number of Purchases")
plt.show()

plt.boxplot(rfm["Recency"])
plt.title("Recency Boxplot")
plt.ylabel("Days Since Last Purchase")
plt.show()

plt.scatter(rfm["Frequency"], rfm["Monetary"])
plt.xlabel("Frequency")
plt.ylabel("Monetary")
plt.title("Frequency vs Monetary")
plt.show()

scaler = StandardScaler()
rfm_scaled = scaler.fit_transform(rfm)

print(rfm_scaled)

kmeans = KMeans(n_clusters=4, random_state=42)
clusters = kmeans.fit_predict(rfm_scaled)

print(clusters)

rfm["Cluster"] = clusters
print(rfm)

cluster_summary = rfm.groupby("Cluster").mean()
cluster_summary

## labeling the clusters
cluster_names = {
    0: "Regular Customers",
    1: "Inactive / At-Risk Customers",
    2: "Loyal High-Value Customers",
    3: "VIP / Elite Customers"
}
rfm["Segment"] = rfm["Cluster"].map(cluster_names)

rfm[["Cluster", "Segment"]].head()

## The clustering revealed four distinct customer segments: inactive customers with low engagement and spend,
## regular customers with moderate activity, loyal high-value customers with frequent recent purchases,
## and a small VIP segment contributing disproportionately to total revenue.
##This segmentation can be used to tailor retention and marketing strategies.

## choosing the best k
inertia = []

for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(rfm_scaled)
    inertia.append(kmeans.inertia_)

plt.plot(range(1, 11), inertia, marker='o')
plt.xlabel("Number of Clusters (K)")
plt.ylabel("Inertia")
plt.title("Elbow Method for Optimal K")
plt.show()

##I used the Elbow Method to determine the optimal number of clusters by analyzing inertia values across different K values.
##I selected the point where the decrease in inertia began to level off, balancing model simplicity
##with meaningful customer segmentation.

## visualize clusters

cluster_summary = rfm.groupby("Cluster")[["Recency", "Frequency", "Monetary"]].mean()

cluster_summary.plot(kind="bar", figsize=(10,6))
plt.title("Average RFM Values by Cluster")
plt.ylabel("Average Value")
plt.xlabel("Cluster")
plt.xticks(rotation=0)
plt.show()
## This chart highlights the behavioral differences between customer segments, showing clear variation in recency,
## purchase frequency, and monetary value across clusters

import seaborn as sns

plt.figure(figsize=(8,6))
sns.scatterplot(
    data=rfm,
    x="Frequency",
    y="Monetary",
    hue="Cluster",
    palette="tab10"
)
plt.title("Customer Segments: Frequency vs Monetary")
plt.show()
##The scatter plot shows clear separation between customer segments,
##with high-value customers clustering at higher frequency and spending levels.

plt.figure(figsize=(8,6))
sns.scatterplot(
    data=rfm,
    x="Recency",
    y="Frequency",
    hue="Cluster",
    palette="tab10"
)
plt.title("Customer Engagement by Cluster")
plt.show()

##This shows how many customers are in each cluster
rfm["Cluster"].value_counts().sort_index().plot(kind="bar")
plt.title("Number of Customers per Cluster")
plt.xlabel("Cluster")
plt.ylabel("Customers")
plt.show()
##This chart shows the distribution of customers across segments,
##revealing that high-value clusters are smaller but contribute disproportionately to revenue.